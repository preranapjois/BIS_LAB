
import numpy as np
from math import gamma, sin, pi

def electrical_grid_loss(x):
    x = np.array(x)
    return np.sum(x**2 - 10 * np.cos(2 * np.pi * x) + 10)

def cuckoo_search(obj_func, n=15, d=2, lb=-5, ub=5, pa=0.25, iterations=100):
    beta = 1.5
    sigma = (gamma(1 + beta) * sin(pi * beta / 2) /
             (gamma((1 + beta) / 2) * beta * 2 ** ((beta - 1) / 2))) ** (1 / beta)

    nests = np.random.uniform(lb, ub, (n, d))
    fitness = np.array([obj_func(nest) for nest in nests])
    best_nest = nests[np.argmin(fitness)]
    best_fitness = np.min(fitness)

    for t in range(iterations):
        new_nests = np.copy(nests)
        for i in range(n):
            step = np.random.normal(0, sigma, size=d) / (abs(np.random.normal(0, 1, size=d)) ** (1 / beta))
            new_nest = nests[i] + 0.01 * step * (nests[i] - best_nest)
            new_nest = np.clip(new_nest, lb, ub)
            new_nests[i] = new_nest

        new_fitness = np.array([obj_func(nest) for nest in new_nests])

        for i in range(n):
            if new_fitness[i] < fitness[i]:
                fitness[i] = new_fitness[i]
                nests[i] = new_nests[i]

        abandon_mask = np.random.rand(n, d) < pa
        random_nests = np.random.uniform(lb, ub, (n, d))
        nests = np.where(abandon_mask, random_nests, nests)
        fitness = np.array([obj_func(nest) for nest in nests])

        if np.min(fitness) < best_fitness:
            best_fitness = np.min(fitness)
            best_nest = nests[np.argmin(fitness)]

        print(f"Iteration {t+1}: Best Grid Loss = {best_fitness:.10e}")

    return best_nest, best_fitness

best_solution, best_value = cuckoo_search(electrical_grid_loss, n=20, d=3, lb=-5, ub=5, iterations=100)

print("\nOptimal Electrical Grid Configuration:")
print(best_solution)
print("\nMinimum Power Loss (Objective Value):")
print(best_value)

