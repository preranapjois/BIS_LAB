import numpy as np

def electrical_grid_loss(x):
    return np.sum(x**2 - 10 * np.cos(2 * np.pi * x) + 10)

def cuckoo_search(obj_func, n=15, d=2, lb=-5, ub=5, pa=0.25, iterations=100):
    beta = 1.5  
    sigma = (np.math.gamma(1 + beta) * np.sin(np.pi * beta / 2) / 
             (np.math.gamma((1 + beta) / 2) * beta * 2**((beta - 1) / 2))) ** (1 / beta)
    nests = np.random.uniform(lb, ub, (n, d))
    fitness = np.array([obj_func(nest) for nest in nests])
    best_nest = nests[np.argmin(fitness)]
    best_fitness = np.min(fitness)

    for t in range(iterations):
        new_nests = np.empty_like(nests)
        for i in range(n):
            step = np.random.normal(0, sigma, size=d) / abs(np.random.normal(0, 1, size=d))**(1/beta)
            new_nests[i] = nests[i] + 0.01 * step * (nests[i] - best_nest)
            new_nests[i] = np.clip(new_nests[i], lb, ub)
        new_fitness = np.array([obj_func(nest) for nest in new_nests])
        for i in range(n):
            if new_fitness[i] < fitness[i]:
                fitness[i] = new_fitness[i]
                nests[i] = new_nests[i]
        abandon = np.random.rand(n, d) < pa
        new_random_nests = np.random.uniform(lb, ub, (n, d))
        nests = np.where(abandon, new_random_nests, nests)
        fitness = np.array([obj_func(nest) for nest in nests])
        if np.min(fitness) < best_fitness:
            best_fitness = np.min(fitness)
            best_nest = nests[np.argmin(fitness)]
        print(f"Iteration {t+1}: Best Grid Loss = {best_fitness:.10e}")
    return best_nest, best_fitness

best_solution, best_value = cuckoo_search(electrical_grid_loss, n=20, d=3, lb=-5, ub=5, iterations=100)

print("\nOptimal Electrical Grid Configuration:")
print(best_solution)
print("\nMinimum Power Loss (Objective Value):")
print(best_value)
