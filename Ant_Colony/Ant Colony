import numpy as np
import random

# --- Problem setup: Bus route (like TSP) ---
# Each city represents a bus stop. Distances simulate traffic conditions.
num_stops = 6  # number of bus stops
np.random.seed(42)

# Distance matrix (symmetric), with random "traffic delays"
distances = np.random.randint(10, 100, size=(num_stops, num_stops))
for i in range(num_stops):
    distances[i][i] = 0
    for j in range(i+1, num_stops):
        distances[j][i] = distances[i][j]

# --- ACO parameters ---
num_ants = 10
num_iterations = 100
alpha = 1.0        # pheromone importance
beta = 5.0         # distance importance
evaporation_rate = 0.5
Q = 100  # pheromone deposit factor

# Initialize pheromone trails
pheromone = np.ones((num_stops, num_stops))

# --- Helper function: compute route length ---
def route_distance(route):
    total = 0
    for i in range(len(route) - 1):
        total += distances[route[i]][route[i + 1]]
    total += distances[route[-1]][route[0]]  # return to depot
    return total

# --- ACO main loop ---
best_route = None
best_distance = float("inf")

for iteration in range(num_iterations):
    all_routes = []
    all_distances = []

    for ant in range(num_ants):
        # Start from a random bus stop
        route = [random.randint(0, num_stops - 1)]
        while len(route) < num_stops:
            i = route[-1]
            unvisited = [j for j in range(num_stops) if j not in route]

            # Calculate probability of going to each unvisited stop
            probabilities = []
            for j in unvisited:
                pheromone_factor = pheromone[i][j] ** alpha
                distance_factor = (1.0 / (distances[i][j] + 1e-10)) ** beta
                probabilities.append(pheromone_factor * distance_factor)

            probabilities = np.array(probabilities)
            probabilities /= probabilities.sum()

            # Choose next stop based on probability
            next_stop = np.random.choice(unvisited, p=probabilities)
            route.append(next_stop)

        # Record route and its length
        total_distance = route_distance(route)
        all_routes.append(route)
        all_distances.append(total_distance)

        # Update best
        if total_distance < best_distance:
            best_distance = total_distance
            best_route = route

    # --- Update pheromones ---
    pheromone *= (1 - evaporation_rate)
    for r, dist in zip(all_routes, all_distances):
        for i in range(len(r) - 1):
            pheromone[r[i]][r[i + 1]] += Q / dist
        pheromone[r[-1]][r[0]] += Q / dist  # return leg

    print(f"Iteration {iteration+1}: Best Distance (Traffic-Aware) = {best_distance:.4f}")

# --- Final result ---
print("\nOptimal Bus Route Found:")
print(" â†’ ".join(str(stop) for stop in best_route))
print(f"Optimal Total Travel Distance (with traffic): {best_distance:.4f}")
